# 목차

- 작게 만들어라!
  - 블록과 들여쓰기
- 한가지만 해라!
  - 함수 내 섹션
- 함수 당 추상화 수준은 하나로!
  - 위에서 아래로 코드 읽기: 내려가기 규칙
- Switch 문
- 서술적인 이름을 사용해라
- 함수 인수
  - 많이 쓰는 단항 형식
  - 플래그 인수
  - 이항 인수
  - 삼항 함수
  - 인수 객체
  - 인수 목록
  - 동사와 키워드
- 부수 효과를 일으키지 마라!
  - 출력 인수
- 명령과 조회를 분리하라!
- 오류 코드보다 예외를 사용하라!
  - Try/Catch 블록 뽑아내기
  - 오류 처리도 한 가지 작업이다.
  - Error.java 의존성 자석
- 반복하지 마라!
- 구조적 프로그래밍
- 함수를 어떻게 짜죠?
- 결론

# Intro

어떤 프로그램이든 가장 기본적인 단위가 함수다.
함수가 읽기 쉽고 이해하기 쉬운 이유는 무엇일까?
의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

# 작게 만들어라

함수는 작을수록 더 좋다.
하나의 함수는 하나의 이야기를 표현해야 한다.

## 블록과 들여쓰기

if 문/ else 문/while 문 등에 들어가는 불록은 한 줄이어야 한다.
중첩 구조가 생길만큼 함수가 커져서는 안 된다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

# 한 가지만 해라!

> 함수는 한가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
우리가 함수를 만드는 이유는 큰 개념을 (즉, 함수 이름을) 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이다.

## 함수 내 섹션

한 함수에서 여러 작업을 하면 여러 섹션으로 나눠지면 여러 작업을 한다는 증거이다.
한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

# 함수 당 추상화 수준은 하나로!

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야 한다.
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 왜냐하면 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다.
근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

## 위에서 아래로 코드 읽기: 내려가기 규칙

코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한 단계씩 낮아진다.

> TO 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.
>
> > TO 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 수 일반 설정 페이지를 포함한다.
> > TO 슈트 설정 페이지를 포함하려면, 부모 계층에서 "SuiteSetUp" 페이지를 찾아 include 문과 페이지 경로를 추가한다.
> > TO 부모 계층을 검색하려면, ....

핵심은 짧으면서 `한 가지` 만 하는 함수다.

# Switch 문

switch 문은 작게 만들기 어렵다.
`한 가지` 작업만 하는 switch 문도 만들기 어렵다. 본질적으로 switch 문은 N가지를 처리한다.
switch 문을 저차원 클래스에 숨기고 절대 반복하지 않는 방법은 있다. 다형성을 이용한다.

# 서술적인 이름을 사용하라!

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. - 워드

한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다.
함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
이름을 붙일 때는 일관성이 있어야 한다.

# 함수 인수

함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)는 가능한 피하는 편이 좋다.
4개 이상(다항)은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안된다.
인수는 어렵다. 인수는 개념을 이해하기 어렵게 만들기 때문이다.
최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우이다.

## 많이 쓰는 단항 형식

- 인수에 질문을 던지는 경우
  - `boolean fileExists("MyFile")
- 인수를 뭔가로 변화해 결과를 반환하는 경우
  - `InputStream fileOpen("MyFile")
- 이벤트 함수일 경우(이벤트라는 사실이 코드에 명확히 드러나야 한다.)

위의 3가지가 아니라면 단항 함수는 가급적 피하는게 좋다.

## 플래그 인수

플래그 인수는 추하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 것과 마찬가지다.

## 이항 함수

단항 함수보다 이해하기 어렵다. 이항 함수가의 인수가 자연적인 순서가 없으면 쉽게 읽히지 않고, 이해하기 힘들다.

## 삼항 함수

이항 함수보다 훨씬 더 이해하기 어렵다. 위험도 2배 이상 늘어난다. 삼항 함수를 만들 때는 신중히 고려해야 한다.

## 인수 객체

인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언한다.

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

변수를 묶어 넘기려면 이름을 붙어야 하므로 결국은 개념을 표현하게 된다.

## 인수 목록

인수 개수가 가변적인 함수가 필요하다.

```java
String.format("%s worked %.2f hours.", name, hours);
public String format(String format, Object... args);
```

가변 인수를 취하는 모든 함수에 같은 원리가 적용된다.

## 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필요하다.
단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
함수 이름에 키워드를 추가하는 형식이다. 그러면 인수 순서를 기억할 필요가 없어진다.

# 부수 효과를 일으키지 마라!

부수 효과는 거짓말이다.
부수 효과는 시간적인 결합이나 순서 종속성을 초래한다.

## 출력 인수

객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다.
출력 인수로 사용하라고 설계한 변수가 바로 `this` 이다.
출력 인수를 피해라. 함수에서 상태를 변경해야 한다면 객체 상태를 변경하는 방식을 택해라.

# 명령과 조회를 분리하라!

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다.

# 오류 코드보다 예외를 사용하라!

`try/catch` 를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해 진다.

```java
if (deletePage(page) == E_OK) {
	if (registry.deleteReference(page.name) == E_OK) {
		if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
			logger.log("page deleted");
		} else {
			logger.log("configKey not deleted");
		}
	} else {
		logger.log("deleteReference from registry failed");
	}
} else {
	logger.log("delete failed"); return E_ERROR;
}
```

정상 작동과 오류 처리 동작을 뒤섞는 추한 구조이므로 if/else와 마찬가지로 블록을 별도 함수로 뽑아내는 편이 좋다.

```java
public void delete(Page page) {
	try {
		deletePageAndAllReferences(page);
  	} catch (Exception e) {
  		logError(e);
  	}
}

private void deletePageAndAllReferences(Page page) throws Exception {
	deletePage(page);
	registry.deleteReference(page.name);
	configKeys.deleteKey(page.name.makeKey());
}

private void logError(Exception e) {
	logger.log(e.getMessage());
}
```

## 오류 처리도 한 가지 작업이다.

오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 한다.
함수에 키워드 `try` 가 있다면 함수는 `try` 문으로 시작해 `catch/finally` 문으로 끝나야 한다.

## Error.java 의존성 자석

오류를 처리하는 곳곳에서 오류코드를 사용한다면 enum class를 쓰게 되는데 이런 클래스는 의존성 자석이므로, 새 오류코드를 추가하거나 변경할 때 코스트가 많이 필요하다. 그러므로 예외를 사용하는 것이 더 안전하다.

# 반복하지 마라!

중복은 모든 소프트웨어에서 모든 악의 근원이므로 늘 중복을 없애도록 노력해야한다.

# 구조적 프로그래밍

함수가 작다면 함수 `return` 하나여야 한다는 규칙은 별 이익을 제공하지 못한다.

# 함수를 어떻게 짜죠?

소프르웨어를 짜는 행위는 글짓기와 비슷하다.
코드를 작성 하면서 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.
그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
메서드를 줄이고 순서를 바꾼다. 떄로는 전체 클래스를 쪼개기도 한다. 이 와중에 항상 단위 테스트를 통과해야 한다.

# 결론

시스템이라는 이야기를 풀어어가는데 있다. 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아 떨어져야
이야기를 풀어가기가 쉬어진다.
