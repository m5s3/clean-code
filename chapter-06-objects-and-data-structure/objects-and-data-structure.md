# 객체와 자료 구조

## 목차

- 자료 추상화
- 자료/객체 비대칭
- 디미터 법칙
  - 기차 충돌
  - 잡종 구조
  - 구조체 감추기
- 자료 전달 객체
  - 활성 레코드
- 결론

### intro

변수를 비공개하는 이유는 변수에 의존하지 않게 만들기 위해서다.
그렇다면 어째서 수많은 프로그래머가 조회 함수와 설정 함수를 당연하게 공개해 비공개 변수를 외부에 노출할까?

### 자료 추상화

- 6-1 구체적인 Point 클래스

```java
public class Point {
    public double x;
    public double y;
}
```

- 6-2 추상적인 Point 클래스

```java
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```

목록 6-2 는 자료 구조 이상을 표현한다.
목록 6-1 은 확실히 직교좌표계를 사용한다.

변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다.
추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

- 6-3 구체적인 Vehicle 클래스

```java
public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
}
```

- 6-4 추상적인 Vehicle 클래스

```java
public interface Vehicle {
    double getPercentFuelRemaining();
}
```

6-1 보단 6-2 가, 6-3 보단 6-4 가 더 좋다.

자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
개발자는 객체가 포함하는 자룔르 표현할 가장 좋은 방법을 심각하게 고민해야 한다.

### 자료/객체 비대칭

객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개해야 한다.
자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않아야 한다.

> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가 하기 쉽다.
> 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

> 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 모든 함수를 고쳐야 한다.
> 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 모든 클래스를 고쳐야 한다.

분별 있는 프로그래머는 모든 것이 객체라는 생각이 **미신** 임을 잘 안다.
ㄷ떄로는 단순한 자료구조와 절차적인 코드가 가장 적합한 상황도 있다.

### 디미터 법칙

디미터 법칙이란 모듈은 자신이 조작하는 객체의 속상정을 몰라야 한다는 법칙이다.
객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안된다.

#### 기차 충돌

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()
```

#### 잡종 구조

잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다.
잡종 구조는 새로운 함수는 물론이고, 새로운 자료 구조도 추가하기 어렵다.
잡종 구조는 되도록 피하는 편이 좋다.
프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과하다.

#### 구조체 감추기

객체라면 내부 구조를 감춰야 한다.

`ctxt.getAbsolutePathOfScratchDirectoryOptions()`
`ctxt.getScratchDirectoryOption().getAbsolutePath()`

첫 번째 방법은 `ctxt` 객체에 공개해야 하는 메서드가 너무 많다.
두 번째 방법은 `getScratchDirectoryOption()` 이 객체가 아니라 자료 구조를 반환하다고 가정한다.
어느 방법도 좋지 않다.

`ctxt` 가 객체라면 **뭔가를 하라고** 말해야지 속을 드러내라고 말하면 안 된다.

### 자료 전달 객체

자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다.

#### 활성 레코드

활성 레코드는 DTO 의 특수한 형태이다.
조회/설정 및 save, find 같은 탐색 함수도 제공한다.
활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하다. 하지만 이는 바람직 하지 않다
활성 레코드를 자료 구조로 취급해라.

### 결론

객체는 동작을 공개하고 자료를 숨긴다.
시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다.
새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.
